<!DOCTYPE html>
<div id="boot-status" style="font-family:system-ui,Segoe UI,Arial,sans-serif;font-size:14px;padding:8px 12px;background:#fffbe6;border-bottom:1px solid #facc15;display:flex;gap:12px;flex-wrap:wrap">
  <strong>Diagn√≥stico:</strong>
  <span id="diag-react">React‚Ä¶</span>
  <span id="diag-reactdom">ReactDOM‚Ä¶</span>
  <span id="diag-babel">Babel‚Ä¶</span>
  <span id="diag-recharts">Recharts‚Ä¶</span>
  <span id="diag-errors" style="color:#b91c1c"></span>
</div>
<script>
(function(){
  function flag(id, ok){ 
    var el = document.getElementById(id);
    if(!el) return;
    el.textContent = el.textContent.split('‚Ä¶')[0] + (ok ? ' OK ‚úÖ' : ' Falhou ‚ùå');
    el.style.color = ok ? '#166534' : '#b91c1c';
  }
  flag('diag-react', !!window.React);
  flag('diag-reactdom', !!window.ReactDOM);
  flag('diag-babel', !!window.Babel);
  flag('diag-recharts', !!window.Recharts);
  window.onerror = function(message, source, lineno, colno, error){
    var el = document.getElementById('diag-errors');
    if(el){ el.textContent = 'Erro: ' + message + ' (' + lineno + ':' + colno + ')'; }
  };
})();
</script>

<html lang="pt">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>K‚ÄëSIMADIAB</title>
  <!-- TailwindCSS via CDN for styling -->
  <!-- React and ReactDOM UMD builds -->
  <!-- Recharts UMD build -->
  <!-- Lucide React icons (optional).  If unavailable the app falls back to emojis. -->
  <!-- Babel compiler to enable JSX in the browser -->
  
<style>
@media print{
  .no-print{ display:none !important; }
  body{ background:#ffffff !important; color:#000 !important; }
  a[href]:after{ content: ""; } /* clean URLs */
}
</style>

  <link rel="icon" href="favicon.png" />
</head>
<body>  class="bg-gray-50 text-gray-900">
  <div id="root"></div>
  <!-- The main application code is transpiled by Babel in the browser. -->
  <!-- Core CDNs for GitHub Pages -->
<link rel="preconnect" href="https://cdnjs.cloudflare.com">
<script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js" defer></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.development.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.development.min.js"></script>

<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/recharts/2.12.2/Recharts.min.js"></script>
<script type="text/babel" data-presets="react,env">
    /*
      Este ficheiro cont√©m a aplica√ß√£o K‚ÄëSIMADIAB convertida para um formato que
      pode ser executado directamente no browser. As importa√ß√µes ES6 foram
      removidas e substitu√≠das por destrutura√ß√µes das bibliotecas globais
      disponibilizadas via CDN. Tamb√©m foram implementadas v√°rias altera√ß√µes
      solicitadas pelo utilizador:

      1. A simula√ß√£o de pico (Menu 6) procura agora a hora de carga m√°xima
         somente durante o hor√°rio de funcionamento definido no Menu 5. Caso
         nenhuma hora ocupada apresente carga positiva, a primeira hora com
         hor√°rio activo ou a primeira hora do ano √© utilizada como fallback.

      2. A sec√ß√£o de Psicometria (Menu 8) foi expandida para incluir um
         cart√£o "Verifica√ß√£o de C√°lculo (Hora de Pico)" com todos os valores
         interm√©dios utilizados no ponto de equil√≠brio e um gr√°fico de dispers√£o
         simplificado que posiciona os principais pontos do processo num plano
         Temperatura Seca vs Humidade Relativa.

      3. Foram definidos √≠cones de fallback baseados em emojis para o caso de
         a biblioteca lucide-react n√£o estar dispon√≠vel.
    */

    // Para depura√ß√£o, pode definir um handler global de erros (window.onerror)
    // para capturar mensagens de erro e apresent√°-las no ecr√£. Removido na vers√£o final.

    // Obter React hooks e componentes de Recharts a partir dos objectos globais
    const { useState, useEffect, createContext, useContext, useCallback, useMemo } = React;
    const { LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, ReferenceArea, ScatterChart, Scatter } = Recharts;

    // Tentar obter os √≠cones de lucide-react; caso n√£o existam usar emojis como fallback
    const icons = typeof lucideReact !== 'undefined' ? lucideReact : {};
    const Home = icons.Home || ((props) => React.createElement('span', { ...props, title: 'Home' }, 'üè†'));
    const Building = icons.Building || ((props) => React.createElement('span', { ...props, title: 'Edif√≠cio' }, 'üè¢'));
    const MapPin = icons.MapPin || ((props) => React.createElement('span', { ...props, title: 'Localiza√ß√£o' }, 'üìç'));
    const Package = icons.Package || ((props) => React.createElement('span', { ...props, title: 'Espa√ßo' }, 'üì¶'));
    const Users = icons.Users || ((props) => React.createElement('span', { ...props, title: 'Cargas Internas' }, 'üë•'));
    const Clock = icons.Clock || ((props) => React.createElement('span', { ...props, title: 'Hor√°rio' }, 'üïí'));
    const Thermometer = icons.Thermometer || ((props) => React.createElement('span', { ...props, title: 'Pico' }, 'üå°Ô∏è'));
    const Wind = icons.Wind || ((props) => React.createElement('span', { ...props, title: 'Equipamento' }, 'üí®'));
    const BarChart2 = icons.BarChart2 || ((props) => React.createElement('span', { ...props, title: 'Simula√ß√£o Anual' }, 'üìä'));
    const FileText = icons.FileText || ((props) => React.createElement('span', { ...props, title: 'Relat√≥rio' }, 'üìÑ'));
    const GitCompare = icons.GitCompare || ((props) => React.createElement('span', { ...props, title: 'Comparativo' }, 'üîÅ'));
    const DownloadIcon = icons.Download || ((props) => React.createElement('span', { ...props, title: 'Download' }, '‚¨áÔ∏è'));
    const UploadIcon = icons.Upload || ((props) => React.createElement('span', { ...props, title: 'Upload' }, '‚¨ÜÔ∏è'));
    const PieChart = icons.PieChart || ((props) => React.createElement('span', { ...props, title: 'Psicometria' }, 'ü•ß'));

    // --- Constantes & Dados do Cat√°logo (do PDF) ---

    // Distritos de Portugal para o dropdown
    const portugueseDistricts = [
      "Aveiro", "Beja", "Braga", "Bragan√ßa", "Castelo Branco", "Coimbra", "√âvora",
      "Faro", "Guarda", "Leiria", "Lisboa", "Portalegre", "Porto", "Santar√©m",
      "Set√∫bal", "Viana do Castelo", "Vila Real", "Viseu"
    ];

    // Nomes dos Meses
    const monthNames = [
      "Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho",
      "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
    ];

    // Dados dos equipamentos baseados no PDF (Chatron Biocooler Smart)
    const equipmentCatalog = {
      "AE-18V Smart": {
        model: "AE-18V Smart",
        caudal: 18000, // m¬≥/h
        potencia: 1.1, // kW
        tensao: "200-277 V",
        tipo: "Axial, Brushless DC",
        consumoAguaEstimado: 39, // L/h
        capacidadeAgua: 30, // L
        investimento: 2500 // ‚Ç¨ (fict√≠cio)
      },
      "AE-18VS Smart": {
        model: "AE-18VS Smart",
        caudal: 18000,
        potencia: 1.1,
        tensao: "200-277 V",
        tipo: "Axial, Single-phase various speed",
        consumoAguaEstimado: 39,
        capacidadeAgua: 30,
        investimento: 2600
      },
      "AE-18H Smart": {
        model: "AE-18H Smart",
        caudal: 18000,
        potencia: 1.1,
        tensao: "230 V",
        tipo: "Axial, Brushless DC",
        consumoAguaEstimado: 39,
        capacidadeAgua: 30,
        investimento: 2550
      },
      "AE-30V Smart": {
        model: "AE-30V Smart",
        caudal: 30000,
        potencia: 3.0,
        tensao: "400 V AC",
        tipo: "Axial, 3-phase, 2 speed",
        consumoAguaEstimado: 65,
        capacidadeAgua: 55,
        investimento: 4000
      },
      "AE-30VS Smart": {
        model: "AE-30VS Smart",
        caudal: 30000,
        potencia: 3.0,
        tensao: "400 V AC",
        tipo: "Axial, 3-phase, 2 speed",
        consumoAguaEstimado: 65,
        capacidadeAgua: 55,
        investimento: 4100
      },
      "AE-30H Smart": {
        model: "AE-30H Smart",
        caudal: 30000,
        potencia: 3.0,
        tensao: "400 V AC",
        tipo: "Axial, 3-phase, 2 speed",
        consumoAguaEstimado: 65,
        capacidadeAgua: 55,
        investimento: 4050
      }
    };

    // Tabela de Temperatura do PDF (digitalizada)
    const tempPerformanceTable = {
      "20": { "18": 10.4, "20": 12.2, "22": 13.5, "24": 15.0, "26": 16.5, "28": 17.5, "30": 20.4, "32": 21.9, "33": 22.7, "34": 23.4, "35": 24.2, "36": 25.0, "37": 25.7, "38": 26.5, "39": 27.2, "40": 28.0, "42": 29.5, "43": 30.2, "44": 31.0, "45": 31.7 },
      "25": { "18": 11.4, "20": 13.2, "22": 14.5, "24": 16.0, "26": 17.4, "28": 19.0, "30": 21.2, "32": 23.0, "33": 23.5, "34": 24.3, "35": 25.1, "36": 25.9, "37": 26.7, "38": 27.5, "39": 28.2, "40": 29.0, "42": 30.6, "43": 31.4, "44": 32.2, "45": 33.0 },
      "30": { "18": 12.4, "20": 13.7, "22": 15.4, "24": 17.0, "26": 18.5, "28": 20.2, "30": 21.9, "32": 23.5, "33": 24.3, "34": 25.1, "35": 26.0, "36": 26.8, "37": 27.6, "38": 28.4, "39": 29.2, "40": 30.0, "42": 31.7, "43": 32.4, "44": 33.3, "45": 34.1 },
      "40": { "18": 13.5, "20": 15.2, "22": 17.2, "24": 19.0, "26": 20.7, "28": 22.4, "30": 24.6, "32": 25.9, "33": 26.7, "34": 27.6, "35": 28.4, "36": 29.3, "37": 30.1, "38": 31.0, "39": 31.8, "40": 33.6, "42": 35.3, "43": 36.1, "44": 37.0, "45": 38.0 },
      "50": { "18": 15.5, "20": 16.8, "22": 18.8, "24": 20.7, "26": 22.5, "28": 24.2, "30": 26.4, "32": 27.3, "33": 28.2, "34": 29.1, "35": 30.0, "36": 30.8, "37": 31.7, "38": 32.6, "39": 33.5, "40": 35.3, "42": 36.2, "43": 37.0, "44": 37.8, "45": 38.7 },
      "60": { "18": 17.1, "20": 18.7, "22": 20.5, "24": 22.4, "26": 24.3, "28": 26.1, "30": 27.7, "32": 28.6, "33": 29.5, "34": 30.4, "35": 31.3, "36": 32.3, "37": 33.2, "38": 34.1, "39": 35.0, "40": 36.8, "42": 37.8, "43": 38.7, "44": 39.6, "45": 40.5 }
    };

    // --- Helpers de Simula√ß√£o ---

    // Interpola√ß√£o linear simples
    const linearInterp = (x, x1, y1, x2, y2) => {
      if (x1 === x2) return y1;
      return y1 + (x - x1) * (y2 - y1) / (x2 - x1);
    };

    // Calcula a Temperatura de Bolbo H√∫mido (WBT) - F√≥rmula de Stull
    const calculateWBT = (tempExt, hrExt) => {
      try {
        const T = tempExt;
        const RH = hrExt;
        const wbt = T * Math.atan(0.151977 * Math.pow(RH + 8.313659, 0.5)) +
                    Math.atan(T + RH) -
                    Math.atan(RH - 1.676331) +
                    0.00391838 * Math.pow(RH, 1.5) * Math.atan(0.023101 * RH) -
                    4.686035;
        return parseFloat(wbt.toFixed(1));
      } catch (e) {
        return tempExt;
      }
    };

    // Interpola√ß√£o bilinear para a tabela de performance (x = Temp Ext, y = HR Ext)
    const getSupplyTemp = (tempExt, hrExt) => {
      try {
        const hrKeys = Object.keys(tempPerformanceTable).map(Number).sort((a, b) => a - b);
        const tempKeys = Object.keys(tempPerformanceTable["20"]).map(Number).sort((a, b) => a - b);

        // Encontrar HR circundantes
        let y1 = hrKeys.find(k => k >= hrExt) || hrKeys[hrKeys.length - 1];
        let y2 = hrKeys.slice().reverse().find(k => k <= hrExt) || hrKeys[0];
        if (y1 === y2) {
          y1 = hrKeys.find(k => k >= hrExt) || hrKeys[hrKeys.length - 1];
          y2 = hrKeys.find(k => k <= hrExt) || hrKeys[0];
        }
        if (y1 === y2 && hrExt > y1) y2 = hrKeys[hrKeys.indexOf(y1) + 1] || y1;
        if (y1 === y2 && hrExt < y1) y2 = hrKeys[hrKeys.indexOf(y1) - 1] || y1;
        if (y1 > y2) [y1, y2] = [y2, y1];

        // Encontrar Temp circundantes
        let x1 = tempKeys.find(k => k >= tempExt) || tempKeys[tempKeys.length - 1];
        let x2 = tempKeys.slice().reverse().find(k => k <= tempExt) || tempKeys[0];
        if (x1 === x2) {
            x1 = tempKeys.find(k => k >= tempExt) || tempKeys[tempKeys.length - 1];
            x2 = tempKeys.find(k => k <= tempExt) || tempKeys[0];
        }
        if (x1 === x2 && tempExt > x1) x2 = tempKeys[tempKeys.indexOf(x1) + 1] || x1;
        if (x1 === x2 && tempExt < x1) x2 = tempKeys[tempKeys.indexOf(x1) - 1] || x1;
        if (x1 > x2) [x1, x2] = [x2, x1];

        const q11 = tempPerformanceTable[y1.toString()][x1.toString()];
        const q21 = tempPerformanceTable[y1.toString()][x2.toString()];
        const q12 = tempPerformanceTable[y2.toString()][x1.toString()];
        const q22 = tempPerformanceTable[y2.toString()][x2.toString()];

        // Interpola√ß√£o em x e y
        const r1 = linearInterp(tempExt, x1, q11, x2, q21);
        const r2 = linearInterp(tempExt, x1, q12, x2, q22);
        return linearInterp(hrExt, y1, r1, y2, r2);
      } catch (e) {
        console.error("Erro na interpola√ß√£o:", e, {tempExt, hrExt});
        return tempExt;
      }
    };

    // Gera dados clim√°ticos fict√≠cios (8760h)
    const generateMockClimate = (district) => {
      const districtBase = { "Lisboa": 17, "Porto": 15, "Faro": 18, "Bragan√ßa": 12, "Guarda": 10 };
      const baseTemp = districtBase[district] || 15;
      const data = [];
      const start = new Date(2023, 0, 1);
      for (let d = 0; d < 365; d++) {
        for (let h = 0; h < 24; h++) {
          const dayOfYear = d + 1;
          const hourOfDay = h + 1;
          const annualVar = -Math.cos((dayOfYear / 365) * 2 * Math.PI) * 8;
          const dailyVar = -Math.cos(((hourOfDay - 3) / 24) * 2 * Math.PI) * 5;
          const noise = (Math.random() - 0.5) * 2;
          const temp = baseTemp + annualVar + dailyVar + noise;
          let rh = 70 - (temp - baseTemp) * 2.5;
          rh = Math.max(20, Math.min(95, rh + (Math.random() - 0.5) * 10));
          const date = new Date(2023, 0, 1 + d, h);
          data.push({
            hour: d * 24 + h,
            date: date.toISOString(),
            tempExt: parseFloat(temp.toFixed(1)),
            hrExt: parseFloat(rh.toFixed(1)),
            tempHumida: calculateWBT(temp, rh)
          });
        }
      }
      return data;
    };

    // --- Fun√ß√µes de C√°lculo ---

    // Fator de carga do edif√≠cio (W/K) ‚Äì Combina transmiss√£o e infiltra√ß√£o
    const calculateBLF = (space) => {
      const { envelope, infiltration, volume, width, length, height } = space;
      const uMap = { 1: 0.2, 2: 0.4, 3: 0.8, 4: 1.5, 5: 3.0 };
      const areaParedes = (length + width) * 2 * height;
      const areaCobertura = length * width;
      const areaPavimento = length * width;
      const areaVidros = areaParedes * 0.15 * (uMap[envelope.glass] / uMap[envelope.walls]);
      const areaParedesOpacas = areaParedes * 0.85;
      const Q_trans_W_K = (areaParedesOpacas * uMap[envelope.walls]) +
                          (areaCobertura * uMap[envelope.roof]) +
                          (areaPavimento * uMap[envelope.floor]) +
                          (areaVidros * uMap[envelope.glass]);
      const achMap = { 1: 0.1, 2: 0.3, 3: 0.7, 4: 1.5, 5: 3.0 };
      const ach = achMap[infiltration];
      const Q_inf_W_K = 0.34 * volume * ach;
      return Q_trans_W_K + Q_inf_W_K;
    };

    // Carga interna total (W)
    const calculateInternalLoad = (loads, space) => {
      const area = space.width * space.length;
      const totalCargaPessoas = loads.people * loads.metabolism;
      const totalCargaEquip = loads.equipment * area;
      const totalCargaIlum = loads.lighting * area;
      return totalCargaPessoas + totalCargaEquip + totalCargaIlum;
    };

    // Carga de arrefecimento total (kW)
    const calculateTotalLoad_kW = (tempExt, tempInt, blf_W_K, internalLoad_W) => {
      const qExt_W = blf_W_K * (tempExt - tempInt);
      const qTotal_W = qExt_W + internalLoad_W;
      return qTotal_W / 1000;
    };

    // Capacidade de arrefecimento do equipamento (kW)
    const calculateCoolingCapacity_kW = (tempExt, hrExt, tempInt, equipment, quantity) => {
      if (!equipment || quantity === 0) return 0;
      const tempSupply = getSupplyTemp(tempExt, hrExt);
      const caudal_m3_s = (equipment.caudal * quantity) / 3600;
      const densidadeAr = 1.2;
      const cpAr = 1.005;
      const qSensivel_kW = caudal_m3_s * densidadeAr * cpAr * (tempInt - tempSupply);
      return qSensivel_kW;
    };

    // Consumo de √°gua (L/h)
    const calculateWaterConsumption_Lh = (tempExt, hrExt, equipment, quantity) => {
      if (!equipment || quantity === 0) return 0;
      const tempSupply = getSupplyTemp(tempExt, hrExt);
      const deltaT = Math.max(0, tempExt - tempSupply);
      const g_por_kg = (deltaT / 10) * 1.5;
      const kg_por_h = (equipment.caudal * quantity) * 1.2;
      const g_por_h = g_por_kg * kg_por_h;
      return g_por_h / 1000;
    };

    // Fun√ß√£o auxiliar para binning de dados (utilizado no histograma de TBH)
    const binData = (arr, binSize) => {
      const bins = {};
      arr.forEach(val => {
        const bin = Math.floor(val / binSize) * binSize;
        bins[bin] = (bins[bin] || 0) + 1;
      });
      return Object.keys(bins).sort((a,b) => parseFloat(a) - parseFloat(b)).map(bin => ({
        bin: parseFloat(bin),
        count: bins[bin]
      }));
    };

    // --- Componentes de UI reutiliz√°veis ---

    const Card = ({ title, icon: IconComp, children }) => (
      <div className="bg-white rounded-lg shadow-md p-6 mb-8">
        {title && (
          <div className="flex items-center mb-4 space-x-3">
            {IconComp && React.createElement(IconComp, { className: "h-6 w-6 text-blue-400" })}
            <h2 className="text-2xl font-semibold text-gray-900">{title}</h2>
          </div>
        )}
        {children}
      </div>
    );

    const Input = ({ label, value, onChange, unit, ...props }) => (
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700 mb-1">{label}</label>
        <div className="flex items-center space-x-2">
          <input {...props} value={value} onChange={onChange} className="flex-grow bg-gray-700 border border-gray-600 text-gray-900 rounded p-2" />
          {unit && <span className="text-gray-400">{unit}</span>}
        </div>
      </div>
    );

    const Select = ({ label, value, onChange, options }) => (
      <div className="mb-4">
        <label className="block text-sm font-medium text-gray-700 mb-1">{label}</label>
        <select value={value} onChange={onChange} className="bg-gray-700 border border-gray-600 text-gray-900 rounded p-2 w-full">
          {options.map(opt => (
            <option key={opt.value} value={opt.value}>{opt.name}</option>
          ))}
        </select>
      </div>
    );

    const Button = ({ children, onClick, variant = 'primary', disabled }) => {
      const base = 'px-4 py-2 rounded font-semibold focus:outline-none';
      const primary = 'bg-blue-600 hover:bg-blue-700 text-gray-900 disabled:bg-blue-900';
      const secondary = 'bg-gray-600 hover:bg-gray-700 text-gray-900';
      const klass = `${base} ${variant === 'primary' ? primary : secondary}`;
      return (
        <button onClick={onClick} className={klass} disabled={disabled}>{children}</button>
      );
    };

    const StatBox = ({ label, value }) => (
      <div className="bg-gray-700 rounded p-4 text-center">
        <p className="text-sm text-gray-400 mb-1">{label}</p>
        <p className="text-xl font-bold text-gray-900">{value}</p>
      </div>
    );

    const Modal = ({ isOpen, onClose, children }) => {
      if (!isOpen) return null;
      return (
        <div className="fixed inset-0 bg-white bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-50 rounded-lg overflow-hidden shadow-lg max-h-[90vh] w-full max-w-4xl">
            {/* Cabe√ßalho */}
            <div className="flex justify-between items-center p-4 border-b border-gray-200 print:hidden">
              <h3 className="text-xl font-semibold text-gray-900">Relat√≥rio Gerado</h3>
              <button onClick={onClose} className="text-gray-400 hover:text-gray-900 text-3xl">&times;</button>
            </div>
            {/* Corpo */}
            <div className="flex-1 overflow-y-auto p-0 bg-gray-300 print:bg-white print:p-0 print:overflow-visible">
              {children}
            </div>
            {/* Rodap√© */}
            <div className="p-4 bg-white border-t border-gray-200 flex justify-end space-x-4 print:hidden">
              <Button onClick={() => window.print()} variant="primary">Imprimir</Button>
              <Button onClick={onClose} variant="secondary">Fechar</Button>
            </div>
          </div>
        </div>
      );
    };

    // --- Contexto do Projecto ---
    const ProjectContext = createContext();

    const ProjectProvider = ({ children }) => {
      const [projectData, setProjectData] = useState(() => ({
        version: '1.0',
        createdAt: new Date().toISOString().split('T')[0],
        projectName: 'Novo Projeto',
        building: {
          clientName: '',
          nomeEdificio: '',
          address: ''
        },
        costs: {
          electricity: 0.20,
          water: 1.0
        },
        location: {
          district: 'Lisboa',
          climateData: [],
          climateSummary: {},
          latitude: 0,
          longitude: 0
        },
        space: {
          length: 20,
          width: 10,
          height: 4,
          volume: 800,
          envelope: { walls: 3, roof: 3, floor: 3, glass: 3 },
          infiltration: 3
        },
        loads: {
          people: 10,
          metabolism: 120,
          equipment: 15,
          lighting: 10
        },
        schedule: {
          monthlyPatterns: Array.from({ length: 12 }, () => Array.from({ length: 7 }, () => Array(24).fill(false))),
          annualScheduleArray: Array(8760).fill(false)
        },
        simulation: {
          targetTemp: 24,
          peakDay: null,
          annual: null
        },
        equipment: {
          selectedModel: '',
          quantity: 0,
          proposals: []
        }
      }));
      // Actualiza valores aninhados em projectData
      const updateNested = (section, key, value) => {
        setProjectData(prev => ({
          ...prev,
          [section]: {
            ...prev[section],
            [key]: value
          }
        }));
      };
      const updateSchedulePattern = (monthIndex, dayIndex, hourIndex, value) => {
        setProjectData(prev => {
          const newMonthly = prev.schedule.monthlyPatterns.map((m, mi) => {
            if (mi !== monthIndex) return m;
            return m.map((day, di) => {
              if (dayIndex !== null && di !== dayIndex) return day;
              if (hourIndex === 'all') return Array(24).fill(value);
              if (hourIndex === 'copyMonth') return day;
              return day.map((h, hi) => (hi === hourIndex ? value : h));
            });
          });
          const newAnnual = Array(8760).fill(false);
          for (let m = 0; m < 12; m++) {
            const daysInMonth = new Date(2023, m + 1, 0).getDate();
            for (let d = 0; d < daysInMonth; d++) {
              const dayOfWeek = new Date(2023, m, d + 1).getDay();
              const patternDay = newMonthly[m][(dayOfWeek + 6) % 7];
              for (let h = 0; h < 24; h++) {
                const idx = ((new Date(2023, m, d + 1).getTime() - new Date(2023, 0, 1).getTime()) / (3600000)) + h;
                if (patternDay[h]) newAnnual[Math.floor(idx)] = true;
              }
            }
          }
          return {
            ...prev,
            schedule: {
              monthlyPatterns: newMonthly,
              annualScheduleArray: newAnnual
            }
          };
        });
      };
      const updateDeepNested = (section, obj) => {
        setProjectData(prev => ({ ...prev, [section]: { ...prev[section], ...obj } }));
      };
      return (
        <ProjectContext.Provider value={{ projectData, setProjectData, updateNested, updateSchedulePattern, updateDeepNested }}>
          {children}
        </ProjectContext.Provider>
      );
    };

    // --- Componentes de P√°gina ---
    const PageHome = () => {
      const { projectData } = useContext(ProjectContext);
      return (
        <div className="text-center p-10">
          <h1 className="text-6xl font-bold text-gray-900 mb-4">K-SIMADIAB</h1>
          <p className="text-2xl text-blue-400 mb-2">Vers√£o: {projectData.version}</p>
          <p className="text-xl text-gray-400">Data: {projectData.createdAt}</p>
          <p className="mt-8 text-lg text-gray-700 max-w-2xl mx-auto">
            Bem-vindo ao K-SIMADIAB, a sua ferramenta de simula√ß√£o para sistemas de arrefecimento adiab√°tico Chatron.
            Utilize o menu √† esquerda para navegar pelas sec√ß√µes e configurar o seu projecto.
          </p>
        </div>
      );
    };
    const PageSchedule = () => {
      const { projectData, updateSchedulePattern } = useContext(ProjectContext);
      const { schedule } = projectData;
      const [selectedMonth, setSelectedMonth] = useState(0);
      const toggleHour = (dayIndex, hourIndex) => {
        const currentPattern = schedule.monthlyPatterns[selectedMonth][dayIndex][hourIndex];
        updateSchedulePattern(selectedMonth, dayIndex, hourIndex, !currentPattern);
      };
      const setDay = (dayIndex, value) => {
        updateSchedulePattern(selectedMonth, dayIndex, 'all', value);
      };
      const copyMonthPattern = () => {
        updateSchedulePattern(selectedMonth, null, 'copyMonth', null);
      };
      const daysOfWeek = ["Seg", "Ter", "Qua", "Qui", "Sex", "S√°b", "Dom"];
      const totalAnnualHours = schedule.annualScheduleArray.filter(Boolean).length;
      const percentAnnual = (totalAnnualHours / 8760) * 100;
      const annualSchedule = useMemo(() => schedule.annualScheduleArray, [schedule.annualScheduleArray]);
      return (
        <Card title="Hor√°rio de Funcionamento" icon={Clock}>
          <p className="mb-4">Defina as horas de funcionamento do espa√ßo por m√™s e dia da semana. O sistema de climatiza√ß√£o s√≥ funcionar√° durante este per√≠odo.</p>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <StatBox label="N¬∫ de Horas de Ocupa√ß√£o/Ano" value={`${totalAnnualHours} horas`} />
            <StatBox label="% de Ocupa√ß√£o Anual" value={`${percentAnnual.toFixed(1)} %`} />
          </div>
          <div className="flex space-x-4 mb-4 items-end">
            <div className="flex-grow">
              <Select label="M√™s para editar" value={selectedMonth} onChange={(e) => setSelectedMonth(parseInt(e.target.value))} options={monthNames.map((name, index) => ({ name, value: index }))} />
            </div>
            <Button onClick={copyMonthPattern} variant="secondary">Copiar este m√™s para todos</Button>
          </div>
          <div className="overflow-x-auto mt-4">
            <table className="w-full border-collapse">
              <thead>
                <tr>
                  <th className="text-left p-2 border border-gray-200">Dia</th>
                  <th colSpan={4} className="p-2 border border-gray-200 text-center">00-03</th>
                  <th colSpan={4} className="p-2 border border-gray-200 text-center">04-07</th>
                  <th colSpan={4} className="p-2 border border-gray-200 text-center">08-11</th>
                  <th colSpan={4} className="p-2 border border-gray-200 text-center">12-15</th>
                  <th colSpan={4} className="p-2 border border-gray-200 text-center">16-19</th>
                  <th colSpan={4} className="p-2 border border-gray-200 text-center">20-23</th>
                </tr>
              </thead>
              <tbody>
                {daysOfWeek.map((day, dayIndex) => (
                  <tr key={day} className="bg-white even:bg-gray-700/50">
                    <td className="p-2 border border-gray-200 font-semibold text-gray-900">
                      {day}
                      <div className="flex space-x-1 mt-1">
                        <button onClick={() => setDay(dayIndex, true)} className="text-xs bg-blue-600 text-gray-900 px-1 rounded hover:bg-blue-700">Todos</button>
                        <button onClick={() => setDay(dayIndex, false)} className="text-xs bg-gray-600 text-gray-900 px-1 rounded hover:bg-gray-700">Nenhum</button>
                      </div>
                    </td>
                    {schedule.monthlyPatterns[selectedMonth][dayIndex].map((isSet, hourIndex) => (
                      <td key={hourIndex} onClick={() => toggleHour(dayIndex, hourIndex)} className={`border border-gray-200 h-10 w-6 cursor-pointer ${isSet ? 'bg-blue-500' : 'bg-gray-600 hover:bg-gray-500'}`} title={`M√™s ${selectedMonth + 1}, Dia ${day}, Hora ${hourIndex}:00`}></td>
                    ))}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
          <h3 className="text-lg font-semibold text-gray-900 mt-6 mb-2">Visualiza√ß√£o Anual (Mapa 365x24)</h3>
          <div className="bg-gray-50 p-2 rounded overflow-hidden" title="Mapa de calor anual (365 dias x 24 horas)">
            <div className="flex flex-col" style={{width: 365, height: 24, margin: 'auto'}}>
              {Array(24).fill(0).map((_, h) => (
                <div key={h} className="flex" style={{ height: 1 }}>
                  {Array(365).fill(0).map((_, d) => {
                    const isSet = annualSchedule[d * 24 + h];
                    return (
                      <div key={d} className={`w-px h-px ${isSet ? 'bg-blue-500' : 'bg-gray-700'}`} />
                    );
                  })}
                </div>
              ))}
            </div>
          </div>
        </Card>
      );
    };
    const PagePeakSim = () => {
      const { projectData, updateNested } = useContext(ProjectContext);
      const { location, space, loads, simulation, schedule } = projectData;
      const runPeakSimulation = () => {
        if (location.climateData.length === 0) {
          // Se n√£o existirem dados clim√°ticos, informa no console.
          console.error("Por favor, gere ou importe dados clim√°ticos primeiro (Menu 2).");
          return;
        }
        const blf = calculateBLF(space);
        const internalLoad = calculateInternalLoad(loads, space);
        const targetTemp = simulation.targetTemp;
        let peakLoad = -Infinity;
        let peakHourData = null;
        const scheduleArray = (schedule && schedule.annualScheduleArray) ? schedule.annualScheduleArray : [];
        location.climateData.forEach(hourData => {
          if (scheduleArray.length > 0 && !scheduleArray[hourData.hour]) {
            return;
          }
          const load = calculateTotalLoad_kW(hourData.tempExt, targetTemp, blf, internalLoad);
          if (load > peakLoad) {
            peakLoad = load;
            peakHourData = hourData;
          }
        });
        if (!peakHourData) {
          let fallbackIndex = 0;
          if (scheduleArray && scheduleArray.length > 0) {
            fallbackIndex = scheduleArray.findIndex(v => v);
            if (fallbackIndex === -1) fallbackIndex = 0;
          }
          peakHourData = location.climateData[fallbackIndex] || location.climateData[0];
          peakLoad = calculateTotalLoad_kW(peakHourData.tempExt, targetTemp, blf, internalLoad);
        }
        const peakDayIndex = Math.floor(peakHourData.hour / 24);
        const peakDayData = location.climateData.slice(peakDayIndex * 24, (peakDayIndex + 1) * 24);
        const simulationResults = peakDayData.map(h => {
          const qTotal = calculateTotalLoad_kW(h.tempExt, targetTemp, blf, internalLoad);
          const tSupply = getSupplyTemp(h.tempExt, h.hrExt);
          const qInt_W = internalLoad;
          const blf_W_K = blf;
          const tempIntSemArrefecimento = h.tempExt + (qInt_W / blf_W_K);
          return {
            ...h,
            horaDoDia: new Date(h.date).getHours(),
            cargaTotal_kW: qTotal > 0 ? qTotal : 0,
            tempInsuflacao: tSupply,
            tempAlvo: targetTemp,
            tempIntSemArrefecimento: parseFloat(tempIntSemArrefecimento.toFixed(1)),
          };
        });
        updateNested('simulation', 'peakDay', {
          date: new Date(peakHourData.date).toLocaleDateString(),
          peakLoad_kW: peakLoad,
          peakHour: new Date(peakHourData.date).toLocaleString(),
          peakHourIndex: peakHourData.hour,
          peakHourData: peakHourData,
          data: simulationResults
        });
      };
      const tbhHistogramData = useMemo(() => {
        if (location.climateData.length === 0) return [];
        return binData(location.climateData.map(d => d.tempHumida), 1);
      }, [location.climateData]);
      return (
        <Card title="Simular Pico M√°ximo de Arrefecimento" icon={Thermometer}>
          <Input label="Temperatura Interior de Refer√™ncia" type="number" value={simulation.targetTemp} onChange={(e) => updateNested('simulation', 'targetTemp', parseFloat(e.target.value))} unit="¬∞C" />
          <Button onClick={runPeakSimulation}>Simular Dia de Pico</Button>
          {simulation.peakDay && (
            <div className="mt-6">
              <h3 className="text-xl font-semibold text-gray-900 mb-4">Resultados da Simula√ß√£o de Pico</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                <StatBox label="Dia Mais Quente (Pico de Carga)" value={simulation.peakDay.date} />
                <StatBox label="Carga de Pico" value={`${simulation.peakDay.peakLoad_kW.toFixed(2)} kW`} />
              </div>
              <h4 className="text-lg font-semibold text-gray-900 mt-6 mb-2">Evolu√ß√£o no Dia de Pico</h4>
              <PeakDayChart data={simulation.peakDay.data} />
              {/* Bot√£o para imprimir/guardar em PDF usando a funcionalidade nativa do browser */}
              <div className="mt-4">
                <Button onClick={() => window.print()}>Imprimir Relat√≥rio (PDF)</Button>
              </div>
            </div>
          )}
          {tbhHistogramData.length > 0 && (
            <div className="mt-6">
              <h3 className="text-xl font-semibold text-gray-900 mt-6 mb-2">Resumo Anual: Histograma de Temperatura H√∫mida (TBH)</h3>
              <ResponsiveContainer width="100%" height={300}>
                <BarChart data={tbhHistogramData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#4B5563" />
                  <XAxis dataKey="bin" stroke="#9CA3AF" label={{ value: 'Temperatura H√∫mida (¬∞C)', position: 'insideBottom', offset: -10, fill: '#9CA3AF' }} tickFormatter={(tick) => `${tick}¬∞`} />
                  <YAxis stroke="#9CA3AF" label={{ value: 'N¬∫ de Horas', angle: -90, position: 'insideLeft', fill: '#9CA3AF' }} />
                  <Tooltip contentStyle={{ backgroundColor: '#1F2937', border: '1px solid #4B5563' }} />
                  <Legend />
                  <Bar dataKey="count" name="N¬∫ de Horas" fill="#34D399" />
                </BarChart>
              </ResponsiveContainer>
            </div>
          )}
        </Card>
      );
    };
    const PeakDayChart = ({ data }) => {
      if (!data) return null;
      return (
        <ResponsiveContainer width="100%" height={400}>
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="#4B5563" />
            <XAxis dataKey="horaDoDia" stroke="#9CA3AF" unit="h" />
            <YAxis yAxisId="left" stroke="#8884d8" label={{ value: 'Temp (¬∞C)', angle: -90, position: 'insideLeft', fill: '#8884d8' }} />
            <YAxis yAxisId="right" orientation="right" stroke="#82ca9d" label={{ value: 'Carga (kW)', angle: 90, position: 'insideRight', fill: '#82ca9d' }} />
            <Tooltip contentStyle={{ backgroundColor: '#1F2937', border: '1px solid #4B5563' }} />
            <Legend />
            <Line yAxisId="left" type="monotone" dataKey="tempExt" name="Temp. Exterior" stroke="#F87171" />
            <Line yAxisId="left" type="monotone" dataKey="tempIntSemArrefecimento" name="Temp. Int. (s/ Arref.)" stroke="#FBBF24" strokeDasharray="5 5" />
            <Line yAxisId="left" type="monotone" dataKey="tempAlvo" name="Temp. Alvo" stroke="#E5E7EB" strokeDasharray="3 3" />
            <Line yAxisId="left" type="monotone" dataKey="tempInsuflacao" name="Temp. Insufla√ß√£o (Estimada)" stroke="#3B82F6" />
            <Line yAxisId="right" type="monotone" dataKey="cargaTotal_kW" name="Carga T√©rmica" stroke="#34D399" />
          </LineChart>
        </ResponsiveContainer>
      );
    };
    const PagePsychrometry = () => {
      const { projectData } = useContext(ProjectContext);
      const { simulation, equipment, space, loads } = projectData;
      const psychroInfo = useMemo(() => {
        if (!simulation.peakDay || !simulation.peakDay.peakHourData || !equipment.selectedModel) {
          return null;
        }
        const { peakHourData, targetTemp } = simulation.peakDay;
        const { tempExt, hrExt } = peakHourData;
        const equipData = equipmentCatalog[equipment.selectedModel];
        const qty = equipment.quantity;
        const step1 = { etapa: 'Ar Exterior', tempSeca: tempExt.toFixed(1), hr: hrExt.toFixed(1) };
        const tempInsuflacao = getSupplyTemp(tempExt, hrExt);
        const caudal_m3h = equipData.caudal * qty;
        const consumoAgua_Lh = calculateWaterConsumption_Lh(tempExt, hrExt, equipData, qty);
        const step2 = { etapa: 'Sa√≠da do Adiab√°tico (Ar Insuflado)', tempSeca: tempInsuflacao.toFixed(1), hr: '95.0', caudal: caudal_m3h.toLocaleString('pt-PT'), consumoAgua: consumoAgua_Lh.toFixed(1) };
        const blf = calculateBLF(space);
        const internalLoad = calculateInternalLoad(loads, space);
        const tempIntSemArrefecimento = peakHourData.tempExt + (internalLoad / blf);
        const step3 = { etapa: 'Interior (s/ Arrefecimento)', tempSeca: tempIntSemArrefecimento.toFixed(1), hr: hrExt.toFixed(1) };
        const qLoad_kW = calculateTotalLoad_kW(tempExt, targetTemp, blf, internalLoad);
        const qCapacity_kW = calculateCoolingCapacity_kW(tempExt, hrExt, targetTemp, equipData, qty);
        let tempIntResultante;
        if (qCapacity_kW >= qLoad_kW) {
          tempIntResultante = targetTemp;
        } else {
          const caudal_m3_s = (equipData.caudal * qty) / 3600;
          const densidadeAr = 1.2;
          const cpAr = 1.005;
          const m_dot_cp_kW = caudal_m3_s * densidadeAr * cpAr;
          const Q_int_kW = internalLoad / 1000;
          tempIntResultante = (blf * tempExt + Q_int_kW + m_dot_cp_kW * tempInsuflacao) / (blf + m_dot_cp_kW);
        }
        const step4 = { etapa: 'Condi√ß√£o Final do Espa√ßo (Mistura)', tempSeca: tempIntResultante.toFixed(1), hr: hrExt.toFixed(1) };
        const verificationList = [
          { label: 'BLF (W/K)', value: blf.toFixed(1) },
          { label: 'Carga Interna (W)', value: internalLoad.toFixed(1) },
          { label: 'Carga Total (kW)', value: qLoad_kW.toFixed(2) },
          { label: 'Capacidade (kW)', value: qCapacity_kW.toFixed(2) },
          { label: 'Temp. Insufla√ß√£o (¬∞C)', value: tempInsuflacao.toFixed(1) },
          { label: 'Caudal Total (m¬≥/h)', value: caudal_m3h.toLocaleString('pt-PT') },
          { label: 'Consumo √Ågua (L/h)', value: consumoAgua_Lh.toFixed(1) },
          { label: 'Temp. Int. s/ Arref. (¬∞C)', value: tempIntSemArrefecimento.toFixed(1) },
          { label: 'Temp. Final (¬∞C)', value: tempIntResultante.toFixed(1) },
          { label: 'Temp. Alvo (¬∞C)', value: targetTemp.toFixed(1) }
        ];
        const scatterPoints = [
          { name: 'Ar Exterior', tempSeca: parseFloat(step1.tempSeca), hr: parseFloat(step1.hr) },
          { name: 'Sa√≠da Adiab√°tico', tempSeca: parseFloat(step2.tempSeca), hr: 95.0 },
          { name: 'Interior Livre', tempSeca: parseFloat(step3.tempSeca), hr: parseFloat(step3.hr) },
          { name: 'Condi√ß√£o Final', tempSeca: parseFloat(step4.tempSeca), hr: parseFloat(step4.hr) }
        ];
        return { steps: [step1, step2, step3, step4], verificationList, scatterPoints };
      }, [simulation.peakDay, equipment.selectedModel, equipment.quantity, space, loads]);
      if (!psychroInfo) {
        return (
          <Card title="Psicometria (Dia de Pico)" icon={PieChart}>
            <p>Execute a Simula√ß√£o de Pico (Menu 6) e seleccione um Equipamento (Menu 7) para ver esta an√°lise.</p>
          </Card>
        );
      }
      const { steps, verificationList, scatterPoints } = psychroInfo;
      return (
        <Card title="Psicometria (Dia de Pico)" icon={PieChart}>
          <p className="mb-4">An√°lise passo a passo das condi√ß√µes do ar na hora de pico (Pico: {new Date(simulation.peakDay.peakHourData.date).toLocaleString()}).</p>
          <div className="overflow-x-auto">
            <table className="w-full text-left">
              <thead>
                <tr className="bg-gray-700">
                  <th className="p-2">Etapa do Processo</th>
                  <th className="p-2">Temp. Seca (¬∞C)</th>
                  <th className="p-2">Hum. Relativa (%)</th>
                  <th className="p-2">Caudal (m¬≥/h)</th>
                  <th className="p-2">Consumo √Ågua (L/h)</th>
                </tr>
              </thead>
              <tbody>
                {steps.map(p => (
                  <tr key={p.etapa} className="border-b border-gray-200 hover:bg-gray-700/50">
                    <td className="p-2 font-semibold">{p.etapa}</td>
                    <td className="p-2">{p.tempSeca}</td>
                    <td className="p-2">{p.hr}</td>
                    <td className="p-2">{p.caudal || 'N/A'}</td>
                    <td className="p-2">{p.consumoAgua || 'N/A'}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
          {/* Verifica√ß√£o de C√°lculo */}
          <div className="mt-6">
            <h4 className="text-lg font-semibold text-gray-900 mb-2">Verifica√ß√£o de C√°lculo (Hora de Pico)</h4>
            <div className="overflow-x-auto">
              <table className="w-full text-left">
                <tbody>
                  {verificationList.map((item, idx) => (
                    <tr key={idx} className="border-b border-gray-200 hover:bg-gray-700/50">
                      <td className="p-2 font-semibold">{item.label}</td>
                      <td className="p-2">{item.value}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
          {/* Gr√°fico de dispers√£o simplificado */}
          <div className="mt-6">
            <h4 className="text-lg font-semibold text-gray-900 mb-2">Gr√°fico Psicom√©trico (Simplificado)</h4>
            <ResponsiveContainer width="100%" height={300}>
              <ScatterChart>
                <CartesianGrid strokeDasharray="3 3" stroke="#4B5563" />
                <XAxis type="number" dataKey="tempSeca" name="Temp. Seca" unit="¬∞C" stroke="#9CA3AF" />
                <YAxis type="number" dataKey="hr" name="Humidade Relativa" unit="%" stroke="#9CA3AF" />
                <Tooltip />
                <Legend />
                <Scatter name={scatterPoints[0].name} data={[scatterPoints[0]]} fill="#F87171" />
                <Scatter name={scatterPoints[1].name} data={[scatterPoints[1]]} fill="#3B82F6" />
                <Scatter name={scatterPoints[2].name} data={[scatterPoints[2]]} fill="#FBBF24" />
                <Scatter name={scatterPoints[3].name} data={[scatterPoints[3]]} fill="#34D399" />
              </ScatterChart>
            </ResponsiveContainer>
          </div>
          {/* Gr√°fico do dia de pico para contexto */}
          {simulation.peakDay && (
            <div className="mt-8">
              <h4 className="text-lg font-semibold text-gray-900 mt-6 mb-2">Evolu√ß√£o no Dia de Pico (Contexto)</h4>
              <PeakDayChart data={simulation.peakDay.data} />
            </div>
          )}
          {/* Bot√£o de impress√£o para PDF para esta sec√ß√£o */}
          <div className="mt-4">
            <Button onClick={() => window.print()}>Imprimir esta An√°lise (PDF)</Button>
          </div>
        </Card>
      );
    };
    const PagePlaceholder = ({ title }) => (
      <Card title={title} icon={null}>
        <p>Conte√∫do n√£o implementado nesta vers√£o de demonstra√ß√£o.</p>
      </Card>
    );
    const Sidebar = ({ currentPage, onNavigate }) => {
      const menuItems = [
        { id: 0, name: 'P√°gina Inicial', icon: Home },
        { id: 5, name: 'Menu 5 - Hor√°rio', icon: Clock },
        { id: 6, name: 'Menu 6 - Simula√ß√£o Pico', icon: Thermometer },
        { id: 8, name: 'Menu 8 - Psicometria', icon: PieChart }
      ];
      return (
        <nav className="w-64 bg-white text-gray-700 p-4 space-y-2 overflow-y-auto">
          <h2 className="text-2xl font-bold text-gray-900 mb-6 px-2">K-SIMADIAB</h2>
          {menuItems.map(item => (
            <button key={item.id} onClick={() => onNavigate(item.id)} className={`w-full flex items-center space-x-3 px-3 py-2 rounded-md text-left ${currentPage === item.id ? 'bg-blue-600 text-gray-900' : 'hover:bg-gray-700 hover:text-gray-900'}`}>
              {item.icon && React.createElement(item.icon, { className: 'h-5 w-5' })}
              <span>{item.name}</span>
            </button>
          ))}
        </nav>
      );
    };
    function App() {
      const [currentPage, setCurrentPage] = useState(0);
      const renderPage = () => {
        switch (currentPage) {
          case 0: return <PageHome />;
          case 5: return <PageSchedule />;
          case 6: return <PagePeakSim />;
          case 8: return <PagePsychrometry />;
          default: return <PagePlaceholder title="P√°gina em constru√ß√£o" />;
        }
      };
      return (
        <ProjectProvider>
          <div className="flex h-screen bg-gray-50 text-gray-900 font-sans">
            <Sidebar currentPage={currentPage} onNavigate={setCurrentPage} />
            <main className="flex-1 p-8 overflow-y-auto">
              <div className="max-w-7xl mx-auto">
                {renderPage()}
              </div>
            </main>
          </div>
        </ProjectProvider>
      );
    }
    const rootEl = document.getElementById('root');
    const root = ReactDOM.createRoot(rootEl);
    root.render(<App />);
  </script>
</body>
</html>